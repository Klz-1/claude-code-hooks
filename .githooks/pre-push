#!/bin/bash
# Git Pre-Push Hook
# Runs comprehensive checks before pushing to remote

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo -e "${BLUE}[PRE-PUSH]${NC} Running pre-push checks..."

# Get the root directory
GIT_ROOT=$(git rev-parse --show-toplevel)
cd "$GIT_ROOT"

ERRORS=0
WARNINGS=0

# Get current branch
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

# Read input from stdin (remote name and URL)
while read local_ref local_sha remote_ref remote_sha; do
    REMOTE_BRANCH=$(echo "$remote_ref" | sed 's/refs\/heads\///')

    # 1. Prevent direct push to main/master
    echo -e "${BLUE}[CHECK]${NC} Verifying target branch..."
    if [[ "$REMOTE_BRANCH" == "main" ]] || [[ "$REMOTE_BRANCH" == "master" ]]; then
        echo -e "${YELLOW}[WARNING]${NC} Pushing directly to $REMOTE_BRANCH"
        read -p "Are you sure you want to push to $REMOTE_BRANCH? [y/N] " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo -e "${RED}[BLOCKED]${NC} Push to $REMOTE_BRANCH cancelled"
            exit 1
        fi
    fi

    # 2. Check if force push
    if [[ "$local_sha" != "0000000000000000000000000000000000000000" ]]; then
        # Check if this is a force push
        if ! git merge-base --is-ancestor "$remote_sha" "$local_sha" 2>/dev/null; then
            echo -e "${YELLOW}[WARNING]${NC} This appears to be a force push"

            if [[ "$REMOTE_BRANCH" == "main" ]] || [[ "$REMOTE_BRANCH" == "master" ]]; then
                echo -e "${RED}[BLOCKED]${NC} Force push to $REMOTE_BRANCH is not allowed"
                echo -e "${YELLOW}           This could overwrite other developers' work${NC}"
                exit 1
            fi

            read -p "Force push detected. Continue? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                echo -e "${RED}[BLOCKED]${NC} Force push cancelled"
                exit 1
            fi
        fi
    fi
done

# 3. Ensure working directory is clean
echo -e "${BLUE}[CHECK]${NC} Checking working directory status..."
if ! git diff-index --quiet HEAD --; then
    echo -e "${YELLOW}[WARNING]${NC} You have uncommitted changes"
    git status --short
    WARNINGS=$((WARNINGS + 1))
fi

# 4. Run tests if available
if [[ -f "package.json" ]]; then
    if npm run test --if-present --silent 2>/dev/null | grep -q "test"; then
        echo -e "${BLUE}[CHECK]${NC} Running test suite..."

        if ! npm test 2>&1 | tee /tmp/test-output.log; then
            echo -e "${RED}[FAILED]${NC} Tests failed"
            echo -e "${YELLOW}         Review test output above${NC}"
            ERRORS=$((ERRORS + 1))
        else
            echo -e "${GREEN}[PASSED]${NC} All tests passed"
        fi
    else
        echo -e "${YELLOW}[SKIP]${NC} No test script found"
    fi
fi

# 5. Ensure build succeeds
if [[ -f "package.json" ]]; then
    if npm run build --if-present --silent 2>/dev/null | grep -q "build"; then
        echo -e "${BLUE}[CHECK]${NC} Running build..."

        if ! npm run build 2>&1 | tee /tmp/build-output.log; then
            echo -e "${RED}[FAILED]${NC} Build failed"
            echo -e "${YELLOW}         Review build output above${NC}"
            ERRORS=$((ERRORS + 1))
        else
            echo -e "${GREEN}[PASSED]${NC} Build successful"
        fi
    else
        echo -e "${YELLOW}[SKIP]${NC} No build script found"
    fi
fi

# 6. Check for commits with "WIP" or "fixup"
echo -e "${BLUE}[CHECK]${NC} Checking commit messages..."
WIP_COMMITS=$(git log --oneline origin/"$CURRENT_BRANCH"..HEAD 2>/dev/null | grep -iE '(WIP|fixup|squash)' || true)

if [[ -n "$WIP_COMMITS" ]]; then
    echo -e "${YELLOW}[WARNING]${NC} Found WIP/fixup commits:"
    echo "$WIP_COMMITS"
    echo -e "${YELLOW}           Consider squashing before pushing${NC}"
    WARNINGS=$((WARNINGS + 1))
fi

# 7. Check branch is up to date with remote
echo -e "${BLUE}[CHECK]${NC} Checking if branch is up to date..."
git fetch origin "$CURRENT_BRANCH" 2>/dev/null || true

LOCAL=$(git rev-parse @ 2>/dev/null)
REMOTE=$(git rev-parse @{u} 2>/dev/null || echo "")
BASE=$(git merge-base @ @{u} 2>/dev/null || echo "")

if [[ -n "$REMOTE" ]]; then
    if [ "$LOCAL" != "$REMOTE" ] && [ "$LOCAL" = "$BASE" ]; then
        echo -e "${YELLOW}[WARNING]${NC} Your branch is behind origin/$CURRENT_BRANCH"
        echo -e "${YELLOW}           Consider pulling latest changes first${NC}"
        WARNINGS=$((WARNINGS + 1))
    elif [ "$LOCAL" != "$REMOTE" ] && [ "$REMOTE" != "$BASE" ]; then
        echo -e "${YELLOW}[WARNING]${NC} Your branch has diverged from origin/$CURRENT_BRANCH"
        echo -e "${YELLOW}           You may need to rebase or merge${NC}"
        WARNINGS=$((WARNINGS + 1))
    fi
fi

# 8. Check for large files in commits
echo -e "${BLUE}[CHECK]${NC} Checking for large files in commits..."
MAX_SIZE=$((10 * 1024 * 1024)) # 10MB

LARGE_FILES=$(git diff --stat origin/"$CURRENT_BRANCH"..HEAD 2>/dev/null | awk '{print $1}' | while read file; do
    if [[ -f "$file" ]]; then
        size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
        if [[ $size -gt $MAX_SIZE ]]; then
            size_mb=$((size / 1024 / 1024))
            echo "$file (${size_mb}MB)"
        fi
    fi
done)

if [[ -n "$LARGE_FILES" ]]; then
    echo -e "${YELLOW}[WARNING]${NC} Large files detected in commits:"
    echo "$LARGE_FILES"
    echo -e "${YELLOW}           Consider using Git LFS${NC}"
    WARNINGS=$((WARNINGS + 1))
fi

# 9. Verify commit messages follow conventions (optional)
echo -e "${BLUE}[CHECK]${NC} Validating commit message format..."
INVALID_MESSAGES=$(git log --oneline origin/"$CURRENT_BRANCH"..HEAD 2>/dev/null | grep -vE '^[a-f0-9]+ (feat|fix|docs|style|refactor|test|chore|perf|ci|build|revert)(\(.+\))?: .+' || true)

if [[ -n "$INVALID_MESSAGES" ]] && [[ $(echo "$INVALID_MESSAGES" | wc -l) -gt 0 ]]; then
    echo -e "${YELLOW}[WARNING]${NC} Some commits don't follow conventional commit format:"
    echo "$INVALID_MESSAGES" | head -5
    echo -e "${YELLOW}           Consider using: type(scope): description${NC}"
    echo -e "${YELLOW}           Types: feat, fix, docs, style, refactor, test, chore${NC}"
    WARNINGS=$((WARNINGS + 1))
fi

# 10. Check code coverage (if available)
if [[ -f "package.json" ]] && npm run test:coverage --if-present --silent 2>/dev/null | grep -q "coverage"; then
    echo -e "${BLUE}[CHECK]${NC} Checking code coverage..."

    if npm run test:coverage 2>&1 | tee /tmp/coverage-output.log; then
        # Extract coverage percentage if available
        COVERAGE=$(grep -oE '[0-9]+\.[0-9]+%' /tmp/coverage-output.log | head -1 || echo "")
        if [[ -n "$COVERAGE" ]]; then
            echo -e "${GREEN}[INFO]${NC} Code coverage: $COVERAGE"
        fi
    fi
fi

# Final result
echo ""
if [[ $ERRORS -gt 0 ]]; then
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${RED}[BLOCKED]${NC} Pre-push checks failed with $ERRORS error(s)"
    if [[ $WARNINGS -gt 0 ]]; then
        echo -e "${YELLOW}[WARNING]${NC} Also found $WARNINGS warning(s)"
    fi
    echo -e "${RED}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""
    echo "Fix the errors above and try again."
    echo "To bypass this hook (NOT recommended), use: git push --no-verify"
    exit 1
elif [[ $WARNINGS -gt 0 ]]; then
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}[SUCCESS]${NC} Pre-push checks passed with $WARNINGS warning(s)"
    echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    exit 0
else
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${GREEN}[SUCCESS]${NC} All pre-push checks passed!"
    echo -e "${GREEN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    exit 0
fi
